%
% Generated at 26.08.2022 - 16:49:31 by QConnectBase
%

\hypertarget{description-getting-started}{%
\section{Getting Started}\label{description-getting-started}}

We have a plan to publish all the sourcecode as OSS in the near future
so that you can downloaded from PyPI. For the current period, you can
checkout

\href{https://github.com/test-fullautomation/robotframework-qconnect-base}{QConnectBaseLibrary}

After checking out the source completely, you can install by running
below command inside \textbf{robotframework-qconnect-base} directory.

\begin{verbatim}
python setup.py install
\end{verbatim}

\hypertarget{description-usage}{%
\section{Usage}\label{description-usage}}

QConnectBase Library support following keywords for testing connection
in RobotFramework.

\hypertarget{description-connect}{%
\subsection{\texorpdfstring{\textbf{connect}}{connect}}\label{description-connect}}

\begin{quote}
\textbf{Use for establishing a connection.}

\textbf{Syntax}:

\begin{quote}
\textbf{connect}
\texttt{conn\_name={[}conn\_name{]}\ \ \ conn\_type={[}conn\_type{]}\ \ \ conn\_mode={[}conn\_mode{]}\ \ \ conn\_conf={[}conn\_conf{]}}
\end{quote}

\textbf{Arguments}:

\begin{quote}
\textbf{conn\_name}: Name of the connection.

\textbf{conn\_type}: Type of the connection. QConnectBaseLibrary has
supported below connection types:

\begin{quote}
\begin{itemize}
\tightlist
\item
  \textbf{TCPIPClient}: Create a Raw TCPIP connection to TCP Server.
\item
  \textbf{SSHClient}: Create a client connection to a SSH server.
\item
  \textbf{SerialClient}: Create a client connection via Serial Port.
\end{itemize}
\end{quote}

\textbf{conn\_mode}: (unused) Mode of a connection type.

\textbf{conn\_conf}: Configurations for making a connection. Depend on
\textbf{conn\_type} (Type of Connection), there is a suitable
configuration in JSON format as below.

\begin{quote}
\begin{itemize}
\tightlist
\item
  \textbf{TCPIPClient}
\end{itemize}


\begin{robotcode}
{
    "address": [server host], # Optional. Default value is "localhost".
    "port": [server port]     # Optional. Default value is 1234.
    "logfile": [Log file path. Possible values: 'nonlog', 'console', [user define path] ]
 }
\end{robotcode}


\begin{itemize}
\tightlist
\item
  \textbf{SSHClient}
\end{itemize}


\begin{robotcode}
{
    "address" : [server host],  # Optional. Default value is "localhost".
    "port" : [server host],     # Optional. Default value is 22.
    "username" : [username],    # Optional. Default value is "root".
    "password" : [password],    # Optional. Default value is "".
    "authentication" : "password" | "keyfile" | "passwordkeyfile",  # Optional. Default value is "".
    "key_filename" : [filename or list of filenames], # Optional. Default value is null.
    "logfile": [Log file path. Possible values: 'nonlog', 'console', [user define path] ]
 }
\end{robotcode}


\begin{itemize}
\tightlist
\item
  \textbf{SerialClient}
\end{itemize}


\begin{robotcode}
{
    "port" : [comport or null],
    "baudrate" : [Baud rate such as 9600 or 115200 etc.],
    "bytesize" : [Number of data bits. Possible values: 5, 6, 7, 8],
    "stopbits" : [Number of stop bits. Possible values: 1, 1.5, 2],
    "parity" : [Enable parity checking. Possible values: 'N', 'E', 'O', 'M', 'S'],
    "rtscts" : [Enable hardware (RTS/CTS) flow control.],
    "xonxoff" : [Enable software flow control.],
    "logfile": [Log file path. Possible values: 'nonlog', 'console', [user define path] ]
 }
\end{robotcode}


\end{quote}
\end{quote}
\end{quote}
\hypertarget{description-disconnect}{%
\subsection{\texorpdfstring{\textbf{disconnect}}{disconnect}}\label{description-disconnect}}

\begin{quote}
\textbf{Use for disconnect a connection by name.}

\textbf{Syntax}:

\begin{quote}
\textbf{disconnect} \texttt{conn\_name}
\end{quote}

\textbf{Arguments}:

\begin{quote}
\textbf{conn\_name}: Name of the connection.
\end{quote}
\end{quote}

\hypertarget{description-send-command}{%
\subsection{\texorpdfstring{\textbf{send
command}}{send command}}\label{description-send-command}}

\begin{quote}
\textbf{Use for sending a command to the other side of connection.}

\textbf{Syntax}:

\begin{quote}

\textbf{send command}
\texttt{conn\_name={[}conn\_name{]}\ \ \ command={[}command{]}\ \ {[}argument name{]}={[}argument value{]}}
\end{quote}

\textbf{Arguments}:

\begin{quote}
\textbf{conn\_name}: Name of the connection.

\textbf{command}: Command to be sent.
\end{quote}
\end{quote}

\hypertarget{description-verify}{%
\subsection{\texorpdfstring{\textbf{verify}}{verify}}\label{description-verify}}

\begin{quote}
\textbf{Use for verifying a response from the connection if it matched a
pattern.}

\textbf{Syntax}:

\begin{quote}
\textbf{verify}
\texttt{conn\_name={[}conn\_name{]}\ \ \ search\_pattern={[}search\_pattern{]}\ \ timeout={[}timeout{]}\ \ match\_try={[}match try time{]}\ \ fetch\_block={[}is using fetchblock{]}\ \ eob\_pattern={[}end of block pattern{]}\ filter\_pattern={[}filter pattern{]}\ \ send\_cmd={[}send comand{]}\ \ {[}argument name{]}={[}argument value{]}}
\end{quote}

\textbf{Arguments}:

\begin{quote}
\textbf{conn\_name}: Name of the connection.

\textbf{search\_pattern}: Regular expression for matching with the response.

\textbf{timeout}: Timeout for waiting response matching pattern.

\textbf{match\_try}: Number of time for trying to match the pattern.

\textbf{fetch\_block}: If this value is true, every response line will
be put into a block untill a line match \textbf{eob\_pattern} pattern.

\textbf{eob\_pattern}: Regular expression for matching the endline when
using \textbf{fetch\_block}.

\textbf{filter\_pattern}: Regular expression for filtering every line of
block when using \textbf{fetch\_block}.

\textbf{send\_cmd}: Command to be sent to the other side of connection
and waiting for response.
\end{quote}

\textbf{Return value}:

\begin{quote}
\textbf{A corresponding match object if it is found.}

\textbf{E.g.}

\begin{verbatim}
${result} = verify  conn_name=SSH_Connection
                     search_pattern=(?<=\s).*([0-9]..).*(command).$
                     send_cmd=*echo This is the 1st test command.*
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \$\{result\}{[}0{]} will be \textbf{"This is the 1st test command."}
  which is the matched string.
\item
  \$\{result\}{[}1{]} will be \textbf{"1st"} which is the first captured
  string.
\item
  \$\{result\}{[}2{]} will be \textbf{"command"} which is the second
  captured string.
\end{itemize}
\end{quote}
\end{quote}

\hypertarget{description-example}{%
\section{Example}\label{description-example}}

\begin{robotcode}[caption=Robot code example,
linebackgroundcolor=\hlcode{1,5}]
*** Settings ***
Documentation    Suite description
Library     QConnectBase.ConnectionManager

*** Test Cases ***
Test SSH Connection
    # Create config for connection.
    ${config_string}=    catenate
    ...  {
    ...   "address": "127.0.0.1",
    ...   "port": 8022,
    ...   "username": "root",
    ...   "password": "",
    ...   "authentication": "password",
    ...   "key_filename": null
    ...  }
    log to console       \nConnecting with configurations:\n${config_string}
    ${config}=             evaluate        json.loads('''${config_string}''')    json

    # Connect to the target with above configurations.
    connect             conn_name=test_ssh
    ...                 conn_type=SSHClient
    ...                 conn_conf=${config}

    # Send command 'cd ..' and 'ls' then wait for the response '.*' pattern.
    send command                conn_name=test_ssh
    ...                         command=cd ..

    ${res}=     verify                  conn_name=test_ssh
    ...                                 search_pattern=.*
    ...                                 send_cmd=ls
    log to console     ${res}

    # Disconnect
    disconnect  test_ssh
\end{robotcode}

\hypertarget{description-contribution-guidelines}{%
\section{Contribution Guidelines}\label{description-contribution-guidelines}}

QConnectBaseLibrary is designed for ease of making an extension library.
By that way you can take advantage of the QConnectBaseLibrary's
infrastructure for handling your own connection protocal. For creating
an extension library for QConnectBaseLibrary, please following below
steps.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a library package which have the prefix name is
  \textbf{robotframework-qconnect-}\emph{{[}your specific name{]}}.
\item
  Your hadling connection class should be derived from
  \textbf{QConnectionLibrary.connection\_base.ConnectionBase} class.
\item
  In your \emph{Connection Class}, override below attributes and
  methods:
\end{enumerate}

\begin{quote}
\begin{itemize}
\tightlist
\item
  \textbf{\_CONNECTION\_TYPE}: name of your connection type. It will be
  the input of the conn\_type argument when using \textbf{connect}
  keyword. Depend on the type name, the library will detemine the
  correct connection handling class.
\item
  \textbf{\_\_init\_\_(self, \_mode, config)}: in this constructor
  method, you should:
\end{itemize}

\begin{quote}
\begin{itemize}
\item
  Prepare resource for your connection.
\item
  Initialize receiver thread by calling
  \textbf{self.\_init\_thread\_receiver(cls.\_socket\_instance,
  mode="")} method.
\item
  Configure and initialize the lowlevel receiver thread (if it's
  necessary) as below

\begin{verbatim}
self._llrecv_thrd_obj = None
 self._llrecv_thrd_term = threading.Event()
 self._init_thrd_llrecv(cls._socket_instance)
\end{verbatim}
\item
  Incase you use the lowlevel receiver thread. You should implement the
  \textbf{thrd\_llrecv\_from\_connection\_interface()} method. This
  method is a mediate layer which will receive the data from connection
  at the very beginning, do some process then put them in a queue for
  the \textbf{receiver thread} above getting later.
\item
  Create the queue for this connection (use Queue.Queue).
\end{itemize}
\end{quote}

\begin{itemize}
\tightlist
\item
  \textbf{connect()}: implement the way you use to make your own
  connection protocol.
\item
  \textbf{\_read()}: implement the way to receive data from connection.
\item
  \textbf{\_write()}: implement the way to send data via connection.
\item
  \textbf{disconnect()}: implement the way you use to disconnect your
  own connection protocol.
\item
  \textbf{quit()}: implement the way you use to quit connection and
  clean resource.
\end{itemize}
\end{quote}

\hypertarget{description-configure-git-and-correct-eol-handling}{%
\section{Configure Git and correct EOL
handling}\label{description-configure-git-and-correct-eol-handling}}

Here you can find the references for
\href{https://help.github.com/articles/dealing-with-line-endings/}{Dealing
with line endings}.

Every time you press return on your keyboard you're actually inserting
an invisible character called a line ending. Historically, different
operating systems have handled line endings differently. When you view
changes in a file, Git handles line endings in its own way. Since you're
collaborating on projects with Git and GitHub, Git might produce
unexpected results if, for example, you're working on a Windows machine,
and your collaborator has made a change in OS X.

To avoid problems in your diffs, you can configure Git to properly
handle line endings. If you are storing the .gitattributes file directly
inside of your repository, than you can asure that all EOL are manged by
git correctly as defined.

\hypertarget{description-sourcecode-documentation}{%
\section{Sourcecode Documentation}\label{description-sourcecode-documentation}}

For investigating sourcecode, please refer to
\href{../docs/html/index.html}{QConnectBase library documentation}

\hypertarget{description-feedback}{%
\section{Feedback}\label{description-feedback}}

If you have any problem when using the library or think there is a
better solution for any part of the library, I'd love to know it, as
this will all help me to improve the library. Please
don\textquotesingle t hesitate to contact me.

Do share your valuable opinion, I appreciate your honest feedback!

\hypertarget{description-about}{%
\section{About}\label{description-about}}

\hypertarget{description-maintainers}{%
\subsection{Maintainers}\label{description-maintainers}}

\href{mailto:Cuong.NguyenHuynhTri@vn.bosch.com}{Nguyen Huynh Tri Cuong}

\hypertarget{description-contributors}{%
\subsection{Contributors}\label{description-contributors}}

\href{mailto:Cuong.NguyenHuynhTri@vn.bosch.com}{Nguyen Huynh Tri Cuong}

\href{mailto:Thomas.Pollerspoeck@de.bosch.com}{Thomas Pollerspöck}

\hypertarget{description-license}{%
\section{License}\label{description-license}}

Copyright 2020-2022 Robert Bosch GmbH

Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

\begin{quote}
\url{http://www.apache.org/licenses/LICENSE-2.0}
\end{quote}

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
